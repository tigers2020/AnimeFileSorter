# AnimeFileSorter 아키텍처 개요

이 문서는 AnimeFileSorter의 전체 아키텍처와 주요 컴포넌트를 설명합니다.

## 아키텍처 원칙

AnimeFileSorter는 다음 디자인 원칙을 따릅니다:

1. **모델-뷰-컨트롤러(MVC) 패턴**: 사용자 인터페이스, 비즈니스 로직, 데이터 처리 계층을 명확히 분리
2. **단일 책임 원칙(SRP)**: 각 클래스가 한 가지 주요 책임만 갖도록 구성
3. **의존성 주입(DI)**: 컴포넌트 간 느슨한 결합을 통한 유연성 제공
4. **확장성**: 새로운 기능 및 미디어 타입 쉽게 추가 가능
5. **테스트 용이성**: 비즈니스 로직 분리를 통한 자동화된 테스트 지원

## 주요 계층

### 1. 모델 계층 (Models)

데이터 구조 및 비즈니스 엔티티를 정의합니다.

- **MediaItem**: 모든 미디어 항목의 기본 모델
- **Series**: TV 시리즈 관련 데이터
- **Movie**: 영화 관련 데이터
- **FileType/MediaType**: 파일 및 미디어 분류 enum

### 2. 뷰 계층 (Views)

사용자 인터페이스와 화면 표시를 담당합니다.

- **MainWindow**: 애플리케이션의 주요 창
- **DashboardScreen**: 대시보드 화면
- **FileBrowserScreen**: 파일 탐색 및 관리 화면
- **SettingsScreen**: 설정 화면
- **Components**: 재사용 가능한 UI 구성 요소

### 3. 컨트롤러 계층 (Controllers)

모델과 뷰 사이의 중재자 역할을 합니다.

- **FileController**: 파일 스캔 및 정리 작업 조정
- **SettingsController**: 사용자 설정 관리

### 4. 서비스 계층 (Services)

핵심 비즈니스 로직을 구현합니다.

- **ScannerService**: 파일 시스템 스캔 및 파일 분석
- **OrganizerService**: 파일 이동 및 정리 규칙
- **MetadataService**: 외부 API에서 메타데이터 검색

### 5. 저장소 계층 (Repositories)

외부 데이터 소스와의 통신을 담당합니다.

- **TMDBRepository**: TMDB API 통신
- **AniListRepository**: AniList API 통신
- **FileRepository**: 파일 시스템 접근
- **ConfigRepository**: 설정 저장 및 로드

## 데이터 흐름

1. 사용자가 UI에서 작업 시작 (파일 스캔, 정리 등)
2. 컨트롤러가 작업을 받아 적절한 서비스 호출
3. 서비스가 비즈니스 로직 수행, 필요 시 저장소 계층 활용
4. 결과가 다시 컨트롤러를 통해 UI로 전달

## 주요 디자인 패턴

- **옵저버 패턴**: 비동기 작업의 진행 상황 업데이트에 사용
- **전략 패턴**: 다양한 파일 정리 방식을 교체 가능하게 구현
- **팩토리 패턴**: 미디어 항목 생성 시 사용
- **싱글톤 패턴**: 설정 관리자와 로거에 사용

## 확장 포인트

AnimeFileSorter는 다음 영역에서 쉽게 확장 가능합니다:

1. **새로운 미디어 타입**: 기본 `MediaItem` 클래스 확장
2. **추가 메타데이터 소스**: 새로운 저장소 구현
3. **파일명 패턴**: 사용자 정의 가능한 템플릿 시스템
4. **UI 테마**: QSS 스타일시트를 통한 사용자 정의 